<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>小红书文字转图片 AI</title>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/twemoji@12.0.0/2/twemoji.min.js" crossorigin="anonymous"></script>
    <script src="config.js"></script>
    <script src="emoji.js"></script>
    <!-- 添加下面这行来引入 ai-helper.js -->
    <script src="ai-helper.js"></script>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <div class="left-panel">
            <h1>生成带有文本和图片的图像</h1>
            <div class="background-select">
                <span>选择背景：</span>
                <div class="background-images">
                    <!-- 背景选项将通过 JavaScript 动态添加 -->
                </div>
            </div>
            <div class="font-toggle">
                <span>选择字体样式：</span>
                <label>
                    <input type="radio" name="fontStyle" value="normal" checked> 正常
                </label>
                <label>
                    <input type="radio" name="fontStyle" value="handwritten"> 手写
                </label>
            </div>

            <div class="input-tabs">
                <button class="tab-button active" data-tab="ai-writing">AI 助写</button>
                <button class="tab-button" data-tab="manual-input">手动录入</button>
            </div>

            <div class="tab-content" id="ai-writing" style="display: block;">
                <textarea id="ai-input" placeholder="请输入您的内容..."></textarea>
                <button id="ai-polish-button">AI 分段润色</button>
                <a href="ai-redbook.html" class="ai-daily-button">AI每日系列</a>
            </div>

            <div class="tab-content" id="manual-input" style="display: none;">
                <form id="inputForm">
                    <div id="loadingIndicator">字体加载中，请稍候...</div>
                </form>
                <!-- 将浮动按钮移到这里 -->
                <div class="action-buttons">
                    <button type="button" id="generateButton" disabled>生成图像</button>
                    <button type="button" id="aiPolishButton">AI润色</button>
                    <button id="downloadButton" style="display:none;">下载图像</button>
                </div>
            </div>

            <!-- 添加一个加载提示元素 -->
            <div id="polishingIndicator" style="display:none;">正在进行AI润色<span class="loading-dots">...</span></div>
        </div>
        <div class="right-panel">
            <div id="output"></div>
        </div>
    </div>

    <div class="floating-toolbar" id="floatingToolbar" style="display: none;">
        <div class="color-picker-container">
            <span class="color-picker-label">文字颜色</span>
            <div class="color-options" id="textColorOptions"></div>
            <div class="color-picker-custom">
                <input type="color" id="textColorPicker" title="自定义文字颜色" />
            </div>
            <button onclick="applyStyle('foreColor')">应用文字颜色</button>
        </div>
        <div class="toolbar-divider"></div>
        <div class="color-picker-container">
            <span class="color-picker-label">背景颜色</span>
            <div class="color-options" id="bgColorOptions"></div>
            <div class="color-picker-custom">
                <input type="color" id="bgColorPicker" title="自定义背景颜色" />
            </div>
            <button onclick="applyStyle('hiliteColor')">应用背景颜色</button>
        </div>
    </div>
    <script>
        const content = [];

        function addInputGroup(type = 'content', text = '', insertAfter = null) {
            console.log('添加输入组:', type, text);
            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group';

            const textInput = document.createElement('div');
            textInput.className = 'editable';
            textInput.contentEditable = true;
            textInput.innerHTML = text;
            textInput.addEventListener('mouseup', showFloatingToolbar);
            textInput.addEventListener('input', updateContent);

            const textType = document.createElement('select');
            textType.className = 'textType';
            textType.innerHTML = `
                <option value="title">标题</option>
                <option value="content">内容</option>
            `;
            textType.value = type;

            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'input-group-buttons';

            const addButton = document.createElement('button');
            addButton.className = 'add-button';
            addButton.innerHTML = '+';
            addButton.type = 'button';
            addButton.addEventListener('click', () => addInputGroup('content', '', inputGroup));

            const deleteButton = document.createElement('button');
            deleteButton.className = 'delete-button';
            deleteButton.innerHTML = '×';
            deleteButton.type = 'button';
            deleteButton.addEventListener('click', () => {
                if (document.querySelectorAll('.input-group').length > 1) {
                    inputGroup.remove();
                } else {
                    alert('至少保留一个输入框');
                }
            });

            buttonsContainer.appendChild(addButton);
            buttonsContainer.appendChild(deleteButton);

            const labelMap = {
                'title': '标题',
                'content': '内容',
            };

            const label = document.createElement('span');
            label.textContent = labelMap[type] + ': ';
            label.style.marginRight = '5px';

            inputGroup.appendChild(label);
            inputGroup.appendChild(textType);
            inputGroup.appendChild(textInput);
            inputGroup.appendChild(buttonsContainer);

            const inputForm = document.getElementById('inputForm');
            if (insertAfter) {
                insertAfter.parentNode.insertBefore(inputGroup, insertAfter.nextSibling);
            } else {
                inputForm.appendChild(inputGroup);
            }
        }

        function showFloatingToolbar(e) {
            const selection = window.getSelection();
            if (selection.toString().length > 0) {
                const range = selection.getRangeAt(0);
                const rect = range.getBoundingClientRect();
                const toolbar = document.getElementById('floatingToolbar');
                toolbar.style.display = 'flex';
                
                // 调整工具栏位置，确保不会超出视口
                const toolbarRect = toolbar.getBoundingClientRect();
                let left = rect.left + window.scrollX;
                let top = rect.top + window.scrollY - toolbarRect.height - 10;
                
                if (left + toolbarRect.width > window.innerWidth) {
                    left = window.innerWidth - toolbarRect.width - 10;
                }
                if (top < 0) {
                    top = rect.bottom + window.scrollY + 10;
                }
                
                toolbar.style.left = `${left}px`;
                toolbar.style.top = `${top}px`;
            }
        }

        function hideFloatingToolbar(e) {
            if (!e.target.closest('.editable') && !e.target.closest('.floating-toolbar')) {
                document.getElementById('floatingToolbar').style.display = 'none';
            }
        }

        document.addEventListener('mousedown', hideFloatingToolbar);

        document.getElementById('generateButton').addEventListener('click', async () => {
            const textInputs = document.querySelectorAll('.editable');
            const textTypes = document.querySelectorAll('.textType');

            content.length = 0; // 清空内容数组

            textInputs.forEach((textInput, index) => {
                const text = textInput.innerHTML;
                const type = textTypes[index].value;
                if (text.trim()) {
                    content.push({ type, text });
                }
            });

            const fontStyle = document.querySelector('input[name="fontStyle"]:checked').value;
            const pageHeight = fontStyle === 'handwritten' ? 580 : 520;
            const pages = content.length > 0 ? paginateContent(content, pageHeight) : [[]];
            await drawImageWithText(pages);
        });

        document.getElementById('aiPolishButton').addEventListener('click', async () => {
            const aiPolishButton = document.getElementById('aiPolishButton');
            const polishingIndicator = document.getElementById('polishingIndicator');

            // 禁用按钮并显示加载提示
            aiPolishButton.disabled = true;
            aiPolishButton.textContent = '正在润色...';
            polishingIndicator.style.display = 'block';

            try {
                const textInputs = document.querySelectorAll('.editable');
                const textTypes = document.querySelectorAll('.textType');
                
                const contentToPolish = [];
                textInputs.forEach((textInput, index) => {
                    const text = textInput.innerHTML;
                    const type = textTypes[index].value;
                    if (text.trim()) {
                        contentToPolish.push({ type, text });
                    }
                });
                
                if (contentToPolish.length > 0) {
                    const polishedContent = await polishContentWithAI(contentToPolish);
                    updateContentWithPolishedVersion(polishedContent);
                } else {
                    alert('请输入文本');
                }
            } catch (error) {
                console.error('AI润色失败:', error);
                alert('AI润色失败,请稍后重试');
            } finally {
                // 无论成功否,都重新启按钮并隐藏加载提示
                aiPolishButton.disabled = false;
                aiPolishButton.textContent = 'AI润色';
                polishingIndicator.style.display = 'none';
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            renderBackgroundOptions();

            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            function showTab(tabName) {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.style.display = 'none');

                const activeButton = document.querySelector(`.tab-button[data-tab="${tabName}"]`);
                const activeContent = document.getElementById(tabName);

                if (activeButton && activeContent) {
                    activeButton.classList.add('active');
                    activeContent.style.display = 'block';
                }
            }

            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const tabName = button.getAttribute('data-tab');
                    showTab(tabName);
                });
            });

            // 默认显示 AI 助写标签页
            showTab('ai-writing');

            // AI 分段润色按钮点击事件（保留这一个，除之前的重代码）
            document.getElementById('ai-polish-button').addEventListener('click', async () => {
                const aiInput = document.getElementById('ai-input').value;
                if (!aiInput.trim()) {
                    alert('请输入内容后再进行AI分段润色');
                    return;
                }

                try {
                    const polishedContent = await segmentContentWithAI(aiInput);
                    console.log('AI 分段润色结果:', polishedContent);

                    // 切换到手动录入标签页
                    showTab('manual-input');

                    // 清空现有的输入组
                    const inputForm = document.getElementById('inputForm');
                    const existingInputGroups = inputForm.querySelectorAll('.input-group');
                    existingInputGroups.forEach(group => group.remove());

                    // 染新的内容
                    polishedContent.forEach(item => {
                        addInputGroup(item.type, item.text);
                    });

                    // 更新内容数组
                    updateContent();
                } catch (error) {
                    console.error('AI 分段润色败:', error);
                    alert('AI 分段润色失败，请稍后重试');
                }
            });

            const form = document.getElementById('inputForm');
            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                });
            }
        });

        function updateContentWithPolishedVersion(polishedContent) {
            const textInputs = document.querySelectorAll('.editable');
            const textTypes = document.querySelectorAll('.textType');
            
            polishedContent.forEach((item, index) => {
                if (textInputs[index] && textTypes[index]) {
                    textInputs[index].innerHTML = item.text;
                    textTypes[index].value = item.type;
                }
            });
            
            updateContent(); // 更新内容数组
        }

        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function isEmoji(str) {
            console.log('检查是否为 Emoji:', JSON.stringify(str));
            const result = EmojiUtil.containsEmoji(str);
            console.log('isEmoji 结果:', result);
            return result;
        }

        async function getEmojiImage(emoji) {
            console.log('开始为 Emoji 创建图像:', emoji);
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');
                ctx.font = '24px "Noto Color Emoji"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(emoji, 16, 16);
                
                const img = new Image();
                img.onload = () => {
                    console.log('Emoji 图像加载成功:', emoji);
                    resolve(img);
                };
                img.onerror = (error) => {
                    console.error('Emoji 图像加载失败:', emoji, error);
                    resolve(null);
                };
                img.src = canvas.toDataURL();
                console.log('Emoji 图像 URL 创建完成');
            });
        }

        async function drawTextWithEmoji(ctx, canvas, textObject, x, y, maxWidth, maxHeight) {
            const { text, type } = textObject;
            const isTitle = type === 'title';
            const fontStyle = document.querySelector('input[name="fontStyle"]:checked').value;
            
            // 设置最大宽度和字体样式
            if (isTitle) {
                maxWidth = canvas.width - 40;
            } else {
                maxWidth = canvas.width - 80;
            }

            const regularFont = isTitle ? '20px "Microsoft YaHei", "Noto Color Emoji"' : '12px "Microsoft YaHei", "Noto Color Emoji"';
            const handwrittenFont = isTitle ? '20px Chinese, Virgil, "Noto Color Emoji"' : '12px Chinese, Virgil, "Noto Color Emoji"';
            ctx.font = fontStyle === 'handwritten' ? handwrittenFont : regularFont;

            let currentY = y;
            let lineHeight = isTitle ? 30 : 18;
            const initialX = x;

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;

            // 新增：用于存储所有节点内容的数组
            let allSegments = [];

            async function processNode(node, inheritedStyle = {}) {
                let style = { ...inheritedStyle };

                if (node.nodeType === Node.TEXT_NODE) {
                    allSegments.push({ type: 'text', content: node.textContent, style });
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    if (node.style.color) style.color = node.style.color;
                    if (node.style.backgroundColor) style.backgroundColor = node.style.backgroundColor;
                    if (node.style.fontWeight === 'bold') style.font = `bold ${ctx.font}`;
                    if (node.style.fontStyle === 'italic') style.font = `italic ${ctx.font}`;
                    if (node.tagName.toLowerCase() === 'font' && node.getAttribute('color')) {
                        style.color = node.getAttribute('color');
                    }

                    for (let childNode of node.childNodes) {
                        await processNode(childNode, style);
                    }
                }
            }

            await processNode(tempDiv);

            // 处理所有段落并进行换行
            let lines = [];
            let currentLine = { segments: [], width: 0 };

            for (let segment of allSegments) {
                let words = segment.content.split('');
                for (let i = 0; i < words.length; i++) {
                    let char = words[i];
                    let nextChar = words[i + 1];
                    let combinedChar = char + (nextChar || '');

                    // 判断当前字符是否为汉字
                    if (/[\u4e00-\u9fa5]/.test(char)) {
                        // 如果是汉字，直接处理当前字符
                        ctx.font = segment.style.font || ctx.font;
                        let charWidth = ctx.measureText(char).width;
                        if (currentLine.width + charWidth > maxWidth / 2) {
                            lines.push(currentLine);
                            currentLine = { segments: [], width: 0 };
                        }
                        currentLine.segments.push({ type: 'text', content: char, style: segment.style });
                        currentLine.width += charWidth;
                    } else if (isEmoji(combinedChar)) {
                        // 如果是emoji，处理组合字符
                        if (currentLine.width + lineHeight * 1.2 > maxWidth / 2) {
                            lines.push(currentLine);
                            currentLine = { segments: [], width: 0 };
                        }
                        currentLine.segments.push({ type: 'emoji', content: combinedChar, style: segment.style });
                        currentLine.width += lineHeight * 1.2;
                        i++; // 跳过下一个字符，因为已经处理了组合字符
                    } else {
                        // 处理其他字符
                        ctx.font = segment.style.font || ctx.font;
                        let charWidth = ctx.measureText(char).width;
                        if (currentLine.width + charWidth > maxWidth / 2) {
                            lines.push(currentLine);
                            currentLine = { segments: [], width: 0 };
                        }
                        if (currentLine.segments.length > 0 && 
                            currentLine.segments[currentLine.segments.length - 1].type === 'text' &&
                            JSON.stringify(currentLine.segments[currentLine.segments.length - 1].style) === JSON.stringify(segment.style)) {
                            currentLine.segments[currentLine.segments.length - 1].content += char;
                        } else {
                            currentLine.segments.push({ type: 'text', content: char, style: segment.style });
                        }
                        currentLine.width += charWidth;
                    }
                }
            }
            if (currentLine.segments.length > 0) {
                lines.push(currentLine);
            }

            // 绘制所有行
            for (let line of lines) {
                let currentX = isTitle ? (canvas.width / 2 - line.width) / 2 : initialX;
                for (let segment of line.segments) {
                    if (segment.type === 'emoji') {
                        const emojiImg = await getEmojiImage(segment.content);
                        if (emojiImg) {
                            // 调整 y 坐标，使 emoji 与文本基线对齐
                            const emojiY = currentY - lineHeight * 0.7;
                            ctx.drawImage(emojiImg, currentX, emojiY, lineHeight, lineHeight);
                        }
                        currentX += lineHeight * 1;
                    } else {
                        ctx.fillStyle = segment.style.color || 'black';
                        ctx.font = segment.style.font || ctx.font;
                        if (segment.style.backgroundColor && segment.style.backgroundColor !== 'rgba(0, 0, 0, 0)') {
                            ctx.save();
                            ctx.fillStyle = segment.style.backgroundColor;
                            const bgWidth = ctx.measureText(segment.content).width;
                            ctx.fillRect(currentX, currentY - lineHeight * 0.8, bgWidth, lineHeight);
                            ctx.restore();
                        }
                        ctx.fillText(segment.content, currentX, currentY);
                        currentX += ctx.measureText(segment.content).width;
                    }
                }
                currentY += lineHeight;
            }

            return { y: currentY };
        }

        function calculateTextHeight(ctx, text, maxWidth, isTitle) {
            maxWidth -= 20; // 减少右边距

            const lineHeight = isTitle ? 30 : 18;
            let totalHeight = 0;
            let totalLines = 0;

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;

            function processNode(node, style = {}) {
                if (node.nodeType === Node.TEXT_NODE) {
                    const words = node.textContent.split('');
                    let line = '';

                    for (let word of words) {
                        const testLine = line + word;
                        ctx.font = style.font || ctx.font;
                        const metrics = ctx.measureText(testLine);
                        const testWidth = metrics.width;

                        if (testWidth > maxWidth && line !== '') {
                            totalHeight += lineHeight;
                            totalLines += 1;
                            line = word;
                        } else {
                            line = testLine;
                        }
                    }
                    if (line !== '') {
                        totalHeight += lineHeight;
                        totalLines += 1;
                    }
                } else if (node.nodeType === Node.ELEMENT_NODE) {
                    let newStyle = { ...style };
                    if (node.style.color) newStyle.color = node.style.color;
                    if (node.style.fontWeight === 'bold') newStyle.font = `bold ${ctx.font}`;
                    if (node.style.fontStyle === 'italic') newStyle.font = `italic ${ctx.font}`;
                    if (node.style.backgroundColor) newStyle.backgroundColor = node.style.backgroundColor;
                    if (node.tagName.toLowerCase() === 'font' && node.getAttribute('color')) {
                        newStyle.color = node.getAttribute('color');
                    }

                    for (let childNode of node.childNodes) {
                        processNode(childNode, newStyle);
                    }
                }
            }

            processNode(tempDiv);

            // 为样式复杂的文本添加少量额外度
            totalHeight += Math.ceil(totalLines / 4) * lineHeight;

            console.log(`计算高度: 文本="${text.substring(0, 20)}...", 总行数=${totalLines}, 总高度=${totalHeight}`);

            return { totalHeight, totalLines };
        }

        function paginateContent(content, maxHeight) {
            console.log('开始分页，最大高度:', maxHeight);
            const pages = [];
            let currentPage = [];
            let currentHeight = 0;

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.font = '12px Microsoft YaHei';

            // 设置实际用高度，留出一些边距
            const usableHeight = maxHeight ; // 上下各留出 20px 的边距

            content.forEach((item, index) => {
                console.log(`处理第 ${index + 1} 个项目:`, item);
                let itemHeight = 0;
                if (item.type === 'title') {
                    ctx.font = '20px Microsoft YaHei';
                    const { totalHeight } = calculateTextHeight(ctx, item.text, 267 - 40, true);
                    itemHeight = totalHeight + 10; // 增加标题底部间距
                    console.log('标题高度:', itemHeight);
                } else if (item.type === 'content') {
                    ctx.font = '12px Microsoft YaHei';
                    const { totalHeight } = calculateTextHeight(ctx, item.text, 267 - 40, false);
                    itemHeight = totalHeight + 5; // 减内容之间的间距
                    console.log('内容高度:', itemHeight);
                } else {
                    console.error('未知的项类型:', item.type);
                    return;
                }

                console.log('当前页高度:', currentHeight, '项目高度:', itemHeight, '总高度:', currentHeight + itemHeight);

                // 如果当前页剩余空间不足，开始新的一页
                if (currentHeight + itemHeight > usableHeight) {
                    console.log('开始新页面，前页内容:', currentPage);
                    pages.push(currentPage);
                    currentPage = [];
                    currentHeight = 0;
                }
                currentPage.push(item);
                currentHeight += itemHeight;
                console.log('更新后的当前页高度:', currentHeight);
            });

            if (currentPage.length > 0) {
                console.log('添加最后一页，内容:', currentPage);
                pages.push(currentPage);
            }

            console.log('分页完成，总页数:', pages.length);
            return pages;
        }
        

        async function drawImageWithText(pages) {
            console.log('开始绘制图像,总页数:', pages.length);

            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = '';

            // 获取选中的背景
            const selectedBackgroundValue = document.querySelector('.background-option.selected').dataset.value;
            const selectedBackground = config.backgrounds.find(bg => bg.value === selectedBackgroundValue);
            const backgroundUrl = selectedBackground ? selectedBackground.url : config.backgrounds[0].url;

            for (const [pageIndex, page] of pages.entries()) {
                console.log(`绘制第 ${pageIndex + 1} 页`);

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const scale = 2; // 增加分辨率

                canvas.width = 267 * scale;
                canvas.height = 357 * scale;
                ctx.scale(scale, scale);

                try {
                    const background = await loadImage(backgroundUrl);
                    ctx.drawImage(background, 0, 0, canvas.width / scale, canvas.height / scale);

                    // 使用选定背景的起始坐标，如果没有则使用默认值
                    let { x, y } = selectedBackground.startCoordinates || config.defaultStartCoordinates;

                    ctx.font = '20px Microsoft YaHei';
                    y += 35;

                    for (const item of page) {
                        console.log(`绘制项:`, item);

                        if (!item || typeof item !== 'object') {
                            console.error('无效的项:', item);
                            continue;
                        }

                        const fontStyle = document.querySelector('input[name="fontStyle"]:checked').value;
                        if (item.type === 'title') {
                            ctx.font = fontStyle === 'handwritten' ? '20px Chinese, Virgil, "Noto Color Emoji"' : '20px "Microsoft YaHei", "Noto Color Emoji"';
                        } else if (item.type === 'content') {
                            ctx.font = fontStyle === 'handwritten' ? '12px Chinese, Virgil, "Noto Color Emoji"' : '12px "Microsoft YaHei", "Noto Color Emoji"';
                        } else {
                            console.error('未知的项类型:', item.type);
                            continue;
                        }

                        // 计算文本长度
                        const textWidth = ctx.measureText(item.text).width;
                        console.log(`项类型: ${item.type}, 文本长度: ${textWidth}px`);

                        let xPosition;
                        if (item.type === 'title') {
                            // 对于标题，我们不需预先计算 xPosition，因为每行都会在 drawTextWithEmoji 中单独计算
                            const result = await drawTextWithEmoji(ctx, canvas, item, 0, y, canvas.width / scale, canvas.height);
                            y = result.y;
                            y += 5; // 减少标题底部间距
                        } else if (item.type === 'content') {
                            // 内容的渲染保持不变
                            xPosition = 20;
                            ctx.textAlign = 'left';
                            const result = await drawTextWithEmoji(ctx, canvas, item, xPosition, y, canvas.width / scale, canvas.height);
                            y = result.y;
                            y += 5; // 减少内容之间的间距
                        }
                    }

                    const img = new Image();
                    img.src = canvas.toDataURL();
                    img.style.width = '267px'; // 保持页面上展示的大小不变
                    img.style.height = '357px'; // 保持面上展示的大小不变
                    outputDiv.appendChild(img);

                } catch (error) {
                    console.error('加载图像出错:', error);
                }
            }

            const downloadButton = document.getElementById('downloadButton');
            downloadButton.style.display = 'block';
            downloadButton.onclick = () => {
                pages.forEach((page, index) => {
                    const link = document.createElement('a');
                    link.href = document.querySelectorAll('#output img')[index].src;
                    link.download = `生成图像_${index + 1}.png`;
                    link.click();
                });
            };
        }

        // 获取 URL 参数
        function getQueryParams() {
            const params = {};
            const queryString = window.location.search.substring(1);
            const regex = /([^&=]+)=([^&]*)/g;
            let m;
            while (m = regex.exec(queryString)) {
                params[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
            }
            console.log('解析的参数:', params); // 添加日志
            return params;
        }

        // 填充表单
        window.onload = () => {
            const params = getQueryParams();
            const inputForm = document.getElementById('inputForm');
            
            // 移除所有现有的输入组
            const existingInputGroups = inputForm.querySelectorAll('.input-group');
            existingInputGroups.forEach(group => group.remove());

            // 如果有 URL 参数，切换到手动录入标签页
            if (params.title || params.content) {
                showTab('manual-input');
            }

            // 添加输入框
            if (!params.title && !params.content) {
                addInputGroup();
            } else {
                if (params.title) {
                    console.log('添加标题输入框:', params.title); // 添加日志
                    addInputGroup('title', params.title);
                }
                if (params.content) {
                    try {
                        const contentArray = JSON.parse(params.content);
                        console.log('解析的内容数组:', contentArray); // 添加日志
                        contentArray.forEach(content => {
                            console.log('添加内容输入框:', content); // 添加日志
                            addInputGroup('content', content);
                        });
                    } catch (error) {
                        console.error('解析内容参数时出错:', error);
                        addInputGroup('content', params.content); // 如果解析失败，直接添加原始内容
                    }
                }
            }

            // 如果没有添加任何输入框，则添加一个默认的空白输入框
            if (inputForm.querySelectorAll('.input-group').length === 0) {
                addInputGroup();
            }

            // 移除原有的全局添加按钮
            const globalAddButton = document.getElementById('addInputButton');
            if (globalAddButton) {
                globalAddButton.remove();
            }

            // 确保有一个默认选中的背景
            const defaultBackground = document.querySelector('.background-option');
            if (defaultBackground) {
                defaultBackground.classList.add('selected');
            }

            // 在所有字体加载完成后自动生成图片
            WebFont.load({
                custom: {
                    families: ['Virgil', 'Cascadia', 'Chinese', 'Noto Color Emoji'],
                    urls: [
                        'https://excalidraw.com/Virgil.woff2',
                        'https://excalidraw.com/Cascadia.woff2',
                        'https://file.yboshi.com/Chinese.woff2',
                        'https://fonts.googleapis.com/css2?family=Noto+Color+Emoji&display=swap'
                    ]
                },
                active: function() {
                    console.log('所有字体已加载');
                    document.getElementById('generateButton').disabled = false;
                    document.getElementById('loadingIndicator').style.display = 'none';
                    
                    // 自动调用生成图片的函数
                    generateImage();
                },
                loading: function() {
                    console.log('字体加载中');
                    document.getElementById('loadingIndicator').style.display = 'block';
                }
            });
        };

        // 新增 generateImage 函数
        function generateImage() {
            const textInputs = document.querySelectorAll('.editable');
            const textTypes = document.querySelectorAll('.textType');

            content.length = 0; // 清空内容数组

            textInputs.forEach((textInput, index) => {
                const text = textInput.innerHTML;
                const type = textTypes[index].value;
                if (text.trim()) {
                    content.push({ type, text });
                }
            });

            const fontStyle = document.querySelector('input[name="fontStyle"]:checked').value;
            const pageHeight = fontStyle === 'handwritten' ? 580 : 520;
            const pages = content.length > 0 ? paginateContent(content, pageHeight) : [[]];
            drawImageWithText(pages);
        }


        function createColorOptions(containerId, colorType, colors) {
            const container = document.getElementById(containerId);
            colors.forEach(color => {
                const colorOption = document.createElement('div');
                colorOption.className = 'color-option';
                colorOption.style.backgroundColor = color;
                colorOption.onmousedown = (e) => {
                    e.preventDefault(); // 防止去焦点
                    selectColor(colorType, color);
                };
                container.appendChild(colorOption);
            });
        }

        let lastSelection = null;

        function selectColor(colorType, color) {
            if (colorType === 'foreColor') {
                document.getElementById('textColorPicker').value = color;
            } else if (colorType === 'hiliteColor') {
                document.getElementById('bgColorPicker').value = color;
            }
            lastSelection = window.getSelection().getRangeAt(0);
        }

        function applyStyle(command) {
            if (lastSelection) {
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(lastSelection);

                let value;
                if (command === 'foreColor') {
                    value = document.getElementById('textColorPicker').value;
                } else if (command === 'hiliteColor') {
                    value = document.getElementById('bgColorPicker').value;
                }

                document.execCommand(command, false, value);
                updateContent(); // 更新内容
            }
            document.getElementById('floatingToolbar').style.display = 'none';
        }

        // 修改自定义颜色选择器的行为
        document.getElementById('textColorPicker').onchange = (e) => {
            selectColor('foreColor', e.target.value);
        };
        document.getElementById('bgColorPicker').onchange = (e) => {
            selectColor('hiliteColor', e.target.value);
        };

        const textPresetColors = ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
        const bgPresetColors = ['#FFFFFF', '#F0F0F0', '#FFCCCB', '#90EE90', '#ADD8E6', '#FFFACD', '#E6E6FA', '#FFE4B5'];

        createColorOptions('textColorOptions', 'foreColor', textPresetColors);
        createColorOptions('bgColorOptions', 'hiliteColor', bgPresetColors);

        function updateContent() {
            const textInputs = document.querySelectorAll('.editable');
            const textTypes = document.querySelectorAll('.textType');

            content.length = 0; // 清空内容数组

            textInputs.forEach((textInput, index) => {
                const text = textInput.innerHTML;
                const type = textTypes[index].value;
                if (text.trim()) {
                    const computedStyle = window.getComputedStyle(textInput);
                    const style = {
                        color: computedStyle.color,
                        backgroundColor: computedStyle.backgroundColor
                    };
                    content.push({ type, text, style });
                }
            });

            console.log('Updated content:', content);
        }

        // 添加 showTab 函数（如果还没有的话）
        function showTab(tabName) {
            const tabButtons = document.querySelectorAll('.tab-button');
            const tabContents = document.querySelectorAll('.tab-content');

            tabButtons.forEach(btn => btn.classList.remove('active'));
            tabContents.forEach(content => content.style.display = 'none');

            const activeButton = document.querySelector(`.tab-button[data-tab="${tabName}"]`);
            const activeContent = document.getElementById(tabName);

            if (activeButton && activeContent) {
                activeButton.classList.add('active');
                activeContent.style.display = 'block';
            }
        }

        function renderBackgroundOptions() {
            const backgroundImagesContainer = document.querySelector('.background-images');
            backgroundImagesContainer.innerHTML = ''; // 清空现有的背景选项

            config.backgrounds.forEach((bg, index) => {
                const optionContainer = document.createElement('div');
                optionContainer.className = 'background-option-container';
                optionContainer.innerHTML = `
                    <img src="${bg.url}" alt="${bg.name}" data-value="${bg.value}" class="background-option">
                    <span class="background-label">${bg.name}</span>
                `;
                backgroundImagesContainer.appendChild(optionContainer);

                // 为第一个选项添加 'selected' 类
                if (index === 0) {
                    optionContainer.querySelector('.background-option').classList.add('selected');
                }
            });

            // 添加点击事件监听器
            const backgroundOptions = document.querySelectorAll('.background-option');
            backgroundOptions.forEach(option => {
                option.addEventListener('click', () => {
                    backgroundOptions.forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');
                    // 调用生成图片的方法
                    generateImage();
                });
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            renderBackgroundOptions();
            // ... 其他初始化代码 ...
        });

    </script>
</body>
</html>